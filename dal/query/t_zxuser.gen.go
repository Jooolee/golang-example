// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"golang-example/dal/model"
)

func newTZxuser(db *gorm.DB, opts ...gen.DOOption) tZxuser {
	_tZxuser := tZxuser{}

	_tZxuser.tZxuserDo.UseDB(db, opts...)
	_tZxuser.tZxuserDo.UseModel(&model.TZxuser{})

	tableName := _tZxuser.tZxuserDo.TableName()
	_tZxuser.ALL = field.NewAsterisk(tableName)
	_tZxuser.ID = field.NewInt64(tableName, "id")
	_tZxuser.SourceID = field.NewString(tableName, "source_id")
	_tZxuser.SourceType = field.NewBool(tableName, "source_type")
	_tZxuser.Recommender = field.NewString(tableName, "recommender")
	_tZxuser.NickName = field.NewString(tableName, "nick_name")
	_tZxuser.Avatar = field.NewString(tableName, "avatar")
	_tZxuser.ZjID = field.NewInt64(tableName, "zj_id")
	_tZxuser.Status = field.NewInt32(tableName, "status")
	_tZxuser.CreateTime = field.NewTime(tableName, "create_time")
	_tZxuser.UpdateTime = field.NewTime(tableName, "update_time")

	_tZxuser.fillFieldMap()

	return _tZxuser
}

// tZxuser 咨询用户
type tZxuser struct {
	tZxuserDo

	ALL         field.Asterisk
	ID          field.Int64  // 主键
	SourceID    field.String // 注册ID
	SourceType  field.Bool   // 注册类别
	Recommender field.String // 推荐人
	NickName    field.String // 昵称
	Avatar      field.String // 头像
	ZjID        field.Int64  // 专家ID
	Status      field.Int32  // 状态
	CreateTime  field.Time   // 创建时间
	UpdateTime  field.Time   // 更新时间

	fieldMap map[string]field.Expr
}

func (t tZxuser) Table(newTableName string) *tZxuser {
	t.tZxuserDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tZxuser) As(alias string) *tZxuser {
	t.tZxuserDo.DO = *(t.tZxuserDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tZxuser) updateTableName(table string) *tZxuser {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.SourceID = field.NewString(table, "source_id")
	t.SourceType = field.NewBool(table, "source_type")
	t.Recommender = field.NewString(table, "recommender")
	t.NickName = field.NewString(table, "nick_name")
	t.Avatar = field.NewString(table, "avatar")
	t.ZjID = field.NewInt64(table, "zj_id")
	t.Status = field.NewInt32(table, "status")
	t.CreateTime = field.NewTime(table, "create_time")
	t.UpdateTime = field.NewTime(table, "update_time")

	t.fillFieldMap()

	return t
}

func (t *tZxuser) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tZxuser) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 10)
	t.fieldMap["id"] = t.ID
	t.fieldMap["source_id"] = t.SourceID
	t.fieldMap["source_type"] = t.SourceType
	t.fieldMap["recommender"] = t.Recommender
	t.fieldMap["nick_name"] = t.NickName
	t.fieldMap["avatar"] = t.Avatar
	t.fieldMap["zj_id"] = t.ZjID
	t.fieldMap["status"] = t.Status
	t.fieldMap["create_time"] = t.CreateTime
	t.fieldMap["update_time"] = t.UpdateTime
}

func (t tZxuser) clone(db *gorm.DB) tZxuser {
	t.tZxuserDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tZxuser) replaceDB(db *gorm.DB) tZxuser {
	t.tZxuserDo.ReplaceDB(db)
	return t
}

type tZxuserDo struct{ gen.DO }

type ITZxuserDo interface {
	gen.SubQuery
	Debug() ITZxuserDo
	WithContext(ctx context.Context) ITZxuserDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITZxuserDo
	WriteDB() ITZxuserDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITZxuserDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITZxuserDo
	Not(conds ...gen.Condition) ITZxuserDo
	Or(conds ...gen.Condition) ITZxuserDo
	Select(conds ...field.Expr) ITZxuserDo
	Where(conds ...gen.Condition) ITZxuserDo
	Order(conds ...field.Expr) ITZxuserDo
	Distinct(cols ...field.Expr) ITZxuserDo
	Omit(cols ...field.Expr) ITZxuserDo
	Join(table schema.Tabler, on ...field.Expr) ITZxuserDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITZxuserDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITZxuserDo
	Group(cols ...field.Expr) ITZxuserDo
	Having(conds ...gen.Condition) ITZxuserDo
	Limit(limit int) ITZxuserDo
	Offset(offset int) ITZxuserDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITZxuserDo
	Unscoped() ITZxuserDo
	Create(values ...*model.TZxuser) error
	CreateInBatches(values []*model.TZxuser, batchSize int) error
	Save(values ...*model.TZxuser) error
	First() (*model.TZxuser, error)
	Take() (*model.TZxuser, error)
	Last() (*model.TZxuser, error)
	Find() ([]*model.TZxuser, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TZxuser, err error)
	FindInBatches(result *[]*model.TZxuser, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TZxuser) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITZxuserDo
	Assign(attrs ...field.AssignExpr) ITZxuserDo
	Joins(fields ...field.RelationField) ITZxuserDo
	Preload(fields ...field.RelationField) ITZxuserDo
	FirstOrInit() (*model.TZxuser, error)
	FirstOrCreate() (*model.TZxuser, error)
	FindByPage(offset int, limit int) (result []*model.TZxuser, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITZxuserDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tZxuserDo) Debug() ITZxuserDo {
	return t.withDO(t.DO.Debug())
}

func (t tZxuserDo) WithContext(ctx context.Context) ITZxuserDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tZxuserDo) ReadDB() ITZxuserDo {
	return t.Clauses(dbresolver.Read)
}

func (t tZxuserDo) WriteDB() ITZxuserDo {
	return t.Clauses(dbresolver.Write)
}

func (t tZxuserDo) Session(config *gorm.Session) ITZxuserDo {
	return t.withDO(t.DO.Session(config))
}

func (t tZxuserDo) Clauses(conds ...clause.Expression) ITZxuserDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tZxuserDo) Returning(value interface{}, columns ...string) ITZxuserDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tZxuserDo) Not(conds ...gen.Condition) ITZxuserDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tZxuserDo) Or(conds ...gen.Condition) ITZxuserDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tZxuserDo) Select(conds ...field.Expr) ITZxuserDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tZxuserDo) Where(conds ...gen.Condition) ITZxuserDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tZxuserDo) Order(conds ...field.Expr) ITZxuserDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tZxuserDo) Distinct(cols ...field.Expr) ITZxuserDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tZxuserDo) Omit(cols ...field.Expr) ITZxuserDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tZxuserDo) Join(table schema.Tabler, on ...field.Expr) ITZxuserDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tZxuserDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITZxuserDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tZxuserDo) RightJoin(table schema.Tabler, on ...field.Expr) ITZxuserDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tZxuserDo) Group(cols ...field.Expr) ITZxuserDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tZxuserDo) Having(conds ...gen.Condition) ITZxuserDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tZxuserDo) Limit(limit int) ITZxuserDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tZxuserDo) Offset(offset int) ITZxuserDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tZxuserDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITZxuserDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tZxuserDo) Unscoped() ITZxuserDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tZxuserDo) Create(values ...*model.TZxuser) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tZxuserDo) CreateInBatches(values []*model.TZxuser, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tZxuserDo) Save(values ...*model.TZxuser) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tZxuserDo) First() (*model.TZxuser, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TZxuser), nil
	}
}

func (t tZxuserDo) Take() (*model.TZxuser, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TZxuser), nil
	}
}

func (t tZxuserDo) Last() (*model.TZxuser, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TZxuser), nil
	}
}

func (t tZxuserDo) Find() ([]*model.TZxuser, error) {
	result, err := t.DO.Find()
	return result.([]*model.TZxuser), err
}

func (t tZxuserDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TZxuser, err error) {
	buf := make([]*model.TZxuser, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tZxuserDo) FindInBatches(result *[]*model.TZxuser, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tZxuserDo) Attrs(attrs ...field.AssignExpr) ITZxuserDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tZxuserDo) Assign(attrs ...field.AssignExpr) ITZxuserDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tZxuserDo) Joins(fields ...field.RelationField) ITZxuserDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tZxuserDo) Preload(fields ...field.RelationField) ITZxuserDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tZxuserDo) FirstOrInit() (*model.TZxuser, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TZxuser), nil
	}
}

func (t tZxuserDo) FirstOrCreate() (*model.TZxuser, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TZxuser), nil
	}
}

func (t tZxuserDo) FindByPage(offset int, limit int) (result []*model.TZxuser, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tZxuserDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tZxuserDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tZxuserDo) Delete(models ...*model.TZxuser) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tZxuserDo) withDO(do gen.Dao) *tZxuserDo {
	t.DO = *do.(*gen.DO)
	return t
}
